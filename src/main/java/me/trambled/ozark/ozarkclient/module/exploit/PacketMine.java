package me.trambled.ozark.ozarkclient.module.exploit;

import me.trambled.ozark.ozarkclient.event.events.EventDamageBlock;
import me.trambled.ozark.ozarkclient.event.events.EventRender;
import me.trambled.ozark.ozarkclient.module.Category;
import me.trambled.ozark.ozarkclient.module.Module;
import me.trambled.ozark.ozarkclient.module.Setting;
import me.trambled.ozark.ozarkclient.util.world.TimerUtil;
import me.trambled.turok.draw.RenderHelp;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

import java.awt.*;

public class PacketMine extends Module {

    public PacketMine() {
        super(Category.EXPLOIT);

        this.name = "PacketMine";
        this.tag = "PacketMine";
        this.description = "Using packets to mine.";
    }

    Setting render = create("Render", "Render", true);

    BlockPos render_pos;
    private boolean outline;
    private boolean solid;
    TimerUtil timer;

    @EventHandler
    private final Listener<EventDamageBlock> on_damage_block = new Listener<>(event -> {
        if (!can_break(event.getPos())) return;

        render_pos = event.getPos();

        mc.player.swingArm(EnumHand.MAIN_HAND);
        mc.player.connection.sendPacket(new CPacketPlayerDigging(
                CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), event.getDirection()
        ));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(
                CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), event.getDirection()
        ));

        event.cancel();

    });

    @Override
    public void render(EventRender event) {

        if (mc.isSingleplayer())
            return;

        Color color = new Color(this.timer.passedMs((int) (2000.0f * getTpsFactor())) ? 0 : 255, this.timer.passedMs((int) (2000.0f * getTpsFactor())) ? 255 : 0, 0, 255);

        if (render_pos == null) return;

        if (mc.world.getBlockState(render_pos).getBlock().equals(Blocks.AIR)) {
            render_pos = null;
            return;
        }

        if (render.get_value(true)) {
            solid = true;
            outline = true;
        }

        if (solid) {
            RenderHelp.prepare("quads");
            RenderHelp.draw_cube(RenderHelp.get_buffer_build(),
                    render_pos.getX(), render_pos.getY(), render_pos.getZ(),
                    1, 1, 1,
                    color.getRed(), color.getGreen(), color.getBlue(),color.getAlpha(),
                    "all"
            );
            RenderHelp.release();
        }

        if (outline) {
            RenderHelp.prepare("lines");
            RenderHelp.draw_cube_line(RenderHelp.get_buffer_build(),
                    render_pos.getX(), render_pos.getY(), render_pos.getZ(),
                    1, 1, 1,
                    color.getRed(), color.getGreen(), color.getBlue(), 255, 1,
                    "all"
            );
            RenderHelp.release();
        }
    }


    private boolean can_break(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public float getTpsFactor() {
        return 20.0f / me.trambled.ozark.ozarkclient.event.EventHandler.INSTANCE.get_tick_rate();
    }
}