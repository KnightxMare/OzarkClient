package me.trambled.ozark.ozarkclient.module.exploit;

import me.trambled.ozark.ozarkclient.event.events.EventDamageBlock;
import me.trambled.ozark.ozarkclient.event.events.EventRender;
import me.trambled.ozark.ozarkclient.module.Category;
import me.trambled.ozark.ozarkclient.module.Module;
import me.trambled.ozark.ozarkclient.module.Setting;
import me.trambled.ozark.ozarkclient.module.render.ChorusViewer;
import me.trambled.ozark.ozarkclient.util.TickRateUtil;
import me.trambled.ozark.ozarkclient.util.TimerUtil;
import me.trambled.turok.draw.RenderHelp;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.entity.Entity;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

import java.awt.*;

public class PacketMine extends Module {
    
    public PacketMine() {
        super(Category.EXPLOIT);

        this.name = "PacketMine";
        this.tag = "PacketMine";
        this.description = "Using packets to mine.";
    }
    Setting render = create("Render", "PacketMineRender",true);

    private final TimerUtil renderTimer = new TimerUtil();
    BlockPos render_pos;

    @EventHandler
    private Listener<EventDamageBlock> on_damage_block = new Listener<>(event -> {
        if (!can_break(event.getPos())) return;

        render_pos = event.getPos();

        mc.player.swingArm(EnumHand.MAIN_HAND);
        mc.player.connection.sendPacket(new CPacketPlayerDigging(
            CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), event.getDirection()
        ));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(
            CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), event.getDirection()
        ));
        
        event.cancel();

    });

    @Override
    public void render(EventRender event) {

        if (render_pos == null) return;

        if (mc.world.getBlockState(render_pos).getBlock().equals(Blocks.AIR)) {
            render_pos = null;
            return;
        }
        if (render.get_value(true)) {
            drawOutline(render_pos, renderTimer.passedMs((long) (2000 * (20 / TickRateUtil.TPS))) ? Color.GREEN : Color.RED);
        }


    }




    private boolean can_break(BlockPos pos)
    {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    private static void drawOutline(BlockPos pos, Color color) {
        final IBlockState iblockstate = mc.world.getBlockState(pos);
        final Entity entity = mc.getRenderViewEntity();
        final double x = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * mc.getRenderPartialTicks();
        final double y = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * mc.getRenderPartialTicks();
        final double z = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * mc.getRenderPartialTicks();
        if (iblockstate.getMaterial() != Material.AIR) {
            ChorusViewer.enableGL3D();
            AxisAlignedBB bb = iblockstate.getSelectedBoundingBox(mc.world, pos).grow(0.0020000000949949026D).offset(-x, -y, -z);
            RenderGlobal.drawSelectionBoundingBox(iblockstate.getSelectedBoundingBox(mc.world, pos).grow(0.0020000000949949026D).offset(-x, -y, -z), color.getRed() / 255F, color.getGreen() / 255F, color.getBlue() / 255F, 1F);
            RenderGlobal.renderFilledBox(bb.minX, bb.minY, bb.minZ, bb.maxX, bb.maxY, bb.maxZ, color.getRed() / 255F, color.getGreen() / 255F, color.getBlue() / 255F, 40 / 255F);
            ChorusViewer.disableGL3D();
        }
    }}